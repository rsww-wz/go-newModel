最小版本选择
    其他语言依赖库的版本选择
        每个依赖管理解决方案都必须解决选择依赖项版本的问题
        当前其他主流语言以及 go module 之前存在的 go 包依赖管理工具
        选择的算法都试图识别任何依赖项的 “最新最大” 版本
        在语义版本控制被正确应用并且得到遵守的情况下，这是有道理的
        在这样的情况下，依赖项的 “最新最大” 版本应该是最稳定和安全的版本
        并且应与较早版本具有向后兼容性
        至少在相同的主版本依赖树中是如此

    go语言依赖库的版本选择
        Go 则采用了最小版本选择算法
        从本质上讲，Go 团队相信 MVS 为 Go 程序实现持久的和可重复的构建提供了最佳的方案
        对于复杂的包依赖场景，Go 核心团队的 Russ Cox 在 “Minimal Version Selection” 一文中
        对 Go 编译器在选择依赖 module 版本时所采用的最小版本选择算法做过形象的解释



最小版本选择算法例子

                        A1
                ↙                    ↘
    B1.1      B1.2          C1.1     C1.2     C.13
    ↓            ↘                    ↓         ↓
    D1.1  D1.2   D1.3                D1.4     F1.1
      ↘    ↓      ↓                   ↓        ↓ ↑
          E1.1   E1.2  ------------  E1.2      G1.1


    | A1 | +| B1.2 | + | C1.2 | = |  A1  |  ==> |  A1  |
            | D1.3 |   | D1.4 |   | B1.2 |      | B1.2 |
            | E1.2 |   | E1.2 |   | C1.2 |      | C1.2 |
                                  | D1.3 |      | D1.4 |
                                  | D1.4 |      | E1.2 |
                                  | E1.2 |


最小版本解释
    1.最小版本选择 (mvs) 以 build list 为中心
      从一个空的 build list 集合开始
      先加入 main module (A1)
      然后递归计算 main module 的 build list


    2.main module (A1) 的一个直接依赖是包 B
      包 B 的所有版本包括：v1.1 和 v1.2
      A1 的 go.mod 明确指明依赖的是包 B v1.2 版本
      并且 v1.2 已经是包 B 的最新版本
      于是选择包 Bv1.2

    3.包 B v1.2 依赖包 D
      包 D 的所有版本包括：v1.1、v1.2、v1.3 和 v1.4
      包 B v1.2 的 go.mod 明确指明依赖的是包 D 的 v1.3 版本
      那么 Go 编译器究竟会选择哪个版本的包 D 呢
      确实有两种选择。
        首选是选择 “最新的” 版本，即 v1.4
        第二个选择是选择包 B v1.2 所需的版本 v1.3
            像 dep 这样的依赖工具将选择 v1.4 版
            并在语义版本化和遵守社会契约的前提下可以正常工作

            但是采用了 go module 机制的 Go 编译器的 MVS 算法会尊重包 B v1.2 的要求
            并选择包 D 的 v1.3 版本
            即在包 B v1.2 的依赖项 (包 D) 的当前所有版本集合中
            Go 会选择满足包 B v1.2 要求的 “最小” 版本

            同理，包 D v1.3 依赖包 E
            Go 编译器同样选择了满足包 D v1.3 版本要求的包 E 的最小版本：v1.2
            这样 main module 在包 B 这个直接依赖项上的 build list 就浮现了出来：[B v1.2, D v1.3, E v1.2]

    4.main module (A1) 的另一个直接依赖是包 C
      按照对包 B 的 build list 的分析
      我们可以得出 main module 在包 C 这个直接依赖项上的 build list：[C v1.2, D v1.4, E v1.2]

    5.接下来，Go 编译器会将包 B 和包 C 的 build list 去重并合并
      形成 rough build list：[A1, B v1.2, C v1.2, D v1.3, D v1.4 和 E v1.2]

    6.在这个过程中，我们看到两个 build list 中都有包 D 但版本不同
      按照语义化版本规范，包D 的 v1.3 和 v1.4 两个版本的主版本号 (major) 相同
      因此这两个版本是兼容的。为了同时满足包B 和包C 的依赖约束
      Go 编译器将选择包D 的 v1.4 版本
      这也是可以同时满足包B 和包C 的依赖约束的最小版本 (如果包 D 有 v1.5、v1.6 版本亦是如此)


依赖一个包的不同版本
    按照语义化版本规范，当代码演化出现与之前版本的不兼容性变化时
    需要升级版本中的 major 版本号
    而 go module 允许在包导入路径中带有 major 版本号
    比如："import github.com/user/repo/v2"，表示所用的包为 v2 版本下的实现
    我们甚至可以在一个项目中同时依赖同一个包的不同版本
