依赖问题
    一个工程稍大一点，通常会依赖各种各样的包
    而Go使用统一的GOPATH管理依赖包，且每个包仅保留一个版本
    而不同的依赖包由各自的版本工具独立管理，所以当所依赖的包在新版本发生接口变更或删除时，会面临很多问题
    为避免此类问题，我们可能会为不同的工程设置不同的GOPATH，或者更改依赖包路径名称。这样手动维护起来也很头疼


vendor介绍
    为了解决版本冲突问题，go语言在1.5官方引入管理包依赖的方式，1.6正式引入
    vendor目录允许不同的代码库拥有它自己的依赖包，并且不同于其他代码库的版本，这就很好的做到了工程的隔离

    其基本思路是
        把所有的依赖包复制到工程代码库中目录里
        然后使用工程内部的依赖包所在目录来重写所有的导入路径


vendor理解
    项目依然是建立在GOPATH 之下的，GOPATH下正常建立项目文件夹

    项目文件夹下可以建立一个文件夹，统一管理源代码 (当然也可以直接散落在项目的根目录下)
    然后项目文件夹下建立一个vendor的目录
    vendor目录下，建立一个src文件夹，src下再建立一个github.com文件夹，用于存放依赖的第三方库
    当开启vendor机制后，go语言会优先搜索vendor下的第三方库

    在vendor机制下，所依赖库的路径不会发生变化
    而且解决了依赖的版本问题

    vendor是不会改变导入路径的，是因为go语言支持在有vendor的目录下优先搜索使用

    如果go语言不支持这种搜索，而使用了vendor的这种思路，也可以解决版本冲突问题
        但是导入路径需要从外部src一直写到内部src的具体包中，导入路径会变得很长
        如果是从GOPATH工程迁移过来的，则需要全部重写导入路径
        但是这些都不是问题，因为go语言支持vendor机制


vendor项目结构
    GOPATH
        bin
        pkg
        src
            github.com (GOPATH 外部库)
                xxx 1.1

            project (项目)
                src (项目源代码)
                vendor
                    src
                        github.com (vendor 内部库)
                            xxx 1.2

    依赖库的路径都是从src下开始的
    这样无论引用的是内部库还是外部库
    引用的路径都不会发生变化


vendor优点
    1.解决了一个项目一个GOPATH的问题(版本冲突，多次下载依赖等问题)
    2.打包当前的工程放到任意机器的$GOPATH/src下都可以通过编译


vendor缺点
    1.开发时，需要手动将其拷贝过来
    2.一旦外部包升级,vendor下的依赖不会跟着升级
    3.无法精确的引用外部包进行版本控制，不能指定引用某个特定版本的外部包
    4.vendor下面并没有源文件记录引用包的版本信息,这个引用外部包升级产生很大的问题，无法评估升级带来的风险

